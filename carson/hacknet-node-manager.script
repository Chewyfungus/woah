hacknetMultiplier = getHacknetMultipliers().production;

//This is the magical function that calculates the production rate of a node
function calcRate(level, ram, cores) {
    return (level * 1.6) *
        Math.pow(1.035, ram - 1) *
        ((cores + 5) / 6) *
        hacknetMultiplier;
}

//Here are the inits for the three lists that will have the Cost-Benefit information for each upgrade in them
levelCostBenAgg = [];
ramCostBenAgg = [];
coreCostBenAgg = [];

//If we have no nodes then we are going to want to wait until we have enough money for at least one node
if (hacknet.numNodes() === 0) {
    while (getServerMoneyAvailable("home") * 0.1 < hacknet.getPurchaseNodeCost()) {
        print("Not Enough Money to Buy Node");
        sleep(3000);
    }
    print("Buying Node");
    hacknet.purchaseNode();
    sleep(1000);
}

//Take inventory of every node and add each to the Cost-Benefit lists (in order so that the indicies of one match the index of the node)
for (i = 0; i < hacknet.numNodes(); i++) {
    print("Checking Node: " + i);
    nodeInfo = hacknet.getNodeStats(i);
    levelCostBenAgg.push(hacknet.getLevelUpgradeCost(i, 1) / (calcRate(nodeInfo.level + 1, nodeInfo.ram, nodeInfo.cores) - nodeInfo.production));
    ramCostBenAgg.push(hacknet.getRamUpgradeCost(i, 1) / (calcRate(nodeInfo.level, nodeInfo.ram * 2, nodeInfo.cores) - nodeInfo.production));
    coreCostBenAgg.push(hacknet.getCoreUpgradeCost(i, 1) / (calcRate(nodeInfo.level, nodeInfo.ram, nodeInfo.cores + 1) - nodeInfo.production));
}

//This is all data for calculating how much better it would be to buy a new server no need to run it every time because it's static
mults = getHacknetMultipliers();
//levelUpgradeCost = 1000 / 2 * 1.04 * mults.levelCost; I thought I would use these but I don't need them
//ramUpgradeCost = 30000 * 1.28 * mults.ramCost;
//coreUpgradeCost = 500000 * 1.48 * mults.coreCost;
newNodeCost = hacknet.getPurchaseNodeCost();

while (true) {
    //Run the cost check again to make sure someone didn't buy nodes
    newNodeCost = hacknet.getPurchaseNodeCost();
    
    //Calculate the cost benefit of buying a new node and upgrading a component of it
    buyServerCostBen = newNodeCost / (1.6 * mults.production);

    //Find the lowest Cost-Ben for each type of upgrade
    minLevelCostBen = Math.min.apply(null, levelCostBenAgg);
    minRamCostBen = Math.min.apply(null, ramCostBenAgg);
    minCoreCostBen = Math.min.apply(null, coreCostBenAgg);
    
    //Debug so I can figure out why it picked a certain node
    print("Starting Path Comparison");
    print(levelCostBenAgg);
    print(ramCostBenAgg);
    print(coreCostBenAgg);

    if (minLevelCostBen <= minRamCostBen && minLevelCostBen <= minCoreCostBen && minLevelCostBen <= buyServerCostBen) {
        //When you have enough money Buy a level
        nodeIndex = levelCostBenAgg.indexOf(minLevelCostBen); //This gets the index of the node. Remember how I said order of that list is important?
        while (getServerMoneyAvailable("home") * 0.1 < hacknet.getLevelUpgradeCost(nodeIndex, 1)) {
            print("Not Enough Money to Upgrade Level of " + nodeIndex);
            sleep(3000);
        }
        print("Upgrading Level of: " + nodeIndex);
        hacknet.upgradeLevel(nodeIndex, 1);

    } else if (minRamCostBen < minLevelCostBen && minRamCostBen < minCoreCostBen && minRamCostBen < buyServerCostBen) {
        //When you have enough money Buy ram
        nodeIndex = ramCostBenAgg.indexOf(minRamCostBen);
        while (getServerMoneyAvailable("home") * 0.1 < hacknet.getRamUpgradeCost(nodeIndex, 1)) {
            print("Not Enough Money to Upgrade Ram of " + nodeIndex);
            sleep(3000);
        }
        print("Upgrading Ram of: " + nodeIndex);
        hacknet.upgradeRam(nodeIndex, 1);
    } else if (minCoreCostBen < minLevelCostBen && minCoreCostBen < minRamCostBen && minCoreCostBen < buyServerCostBen) {
        //When you have enough money Buy a core
        nodeIndex = coreCostBenAgg.indexOf(minCoreCostBen);
        while (getServerMoneyAvailable("home") * 0.1 < hacknet.getCoreUpgradeCost(nodeIndex, 1)) {
            print("Not Enough Money to Upgrade Core of " + nodeIndex);
            sleep(3000);
        }
        print("Upgrading Core of: " + nodeIndex);
        hacknet.upgradeCore(nodeIndex, 1);
    } else if (buyServerCostBen < minLevelCostBen || buyServerCostBen < minRamCostBen || buyServerCostBen < minCoreCostBen) {
        //When you have enough money Buy a server
        while (getServerMoneyAvailable("home") * 0.1 < hacknet.getPurchaseNodeCost()) {
            print("Not Enough Money to Buy Node");
            sleep(3000);
        }
        print("Buying Node");
        nodeIndex = hacknet.purchaseNode();
    }
    nodeInfo = hacknet.getNodeStats(nodeIndex);
    levelCostBenAgg[nodeIndex] = hacknet.getLevelUpgradeCost(nodeIndex, 1) / (calcRate(nodeInfo.level + 1, nodeInfo.ram, nodeInfo.cores) - nodeInfo.production);
    ramCostBenAgg[nodeIndex] = hacknet.getRamUpgradeCost(nodeIndex, 1) / (calcRate(nodeInfo.level, nodeInfo.ram * 2, nodeInfo.cores) - nodeInfo.production);
    coreCostBenAgg[nodeIndex] = hacknet.getCoreUpgradeCost(nodeIndex, 1) / (calcRate(nodeInfo.level, nodeInfo.ram, nodeInfo.cores + 1) - nodeInfo.production);
}